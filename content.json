[{"title":"前端常见知识归纳","date":"2017-07-19T09:35:55.000Z","path":"2017/07/19/2017-07-19/","text":"什么是伪数组？如何将其转化为标准数组？ 什么是伪数组（类数组）： 无法直接调用数组方法或期望 length 属性有什么特殊的行为，但仍可以使用真正数组遍历方法遍历它们。典型的就是 arguments 参数，还有像调用 getElementsByTagName / document.childNodes之类方法，它们都返回的 NodeList 对象都属于伪数组。 如何转换为标准数组？ 可以使用Array.prototype.slice.call(fakeArray)将伪数组转换为真正的Array对象。但对于NodeList则不行，其在IE8下会报错，只能是JS引擎有所限制。因此，如果需要把 NodeList 转换为标准数组，就需要做向下兼容： 1234567891011function realArray(arr) &#123; try &#123; return Array.prototype.slice.call(arr); &#125; catch &#123; var ret = [], len = arr.length; for (; i &lt; len; i++) &#123; ret[i] = (c[i]); &#125; return ret; &#125;&#125; 方法二：使用ES6 数组扩展的 form() 方法 1var arr = Array.from(arguments); 伪数组转换为标准数组的条件： 1、伪数组的键值需要为数字，否则转换后数组均无初始值 2、有 length 属性 数组去重与排序 去重之一：创建一个新数组，使用 indexOf 判断新数组中是否存在值，例： 123456789 const dedupOne = arr =&gt; &#123; let ret = []; for (let i = 0, len = arr.length; i &lt; len; i++) &#123; if (ret.indexOf(arr[i) === -1) &#123; ret.push(arr[i]); &#125; &#125; return ret;&#125; 去重之二：创建一个新对象 123456789101112const dedupTwo = arr = &gt; &#123; let hash = &#123;&#125;, len = arr.length, ret = []; for (let i = 0; i &lt; len; i++) &#123; if (!hash[arr[i]]) &#123; hash[arr[i]] = arr[i]; ret.push(arr[i]); &#125; &#125; return ret;&#125; 数组排序 1234567一般使用 Array 的原生方法 sort() 方法排序。1. 排序顺序可以是字母和数字，并按升序或降序。2. 默认排序是字母升序。3. 在原始数组上排序，不会生成数组副本。使用数字排序，你必须通过一个函数作为参数来调用。函数指定数字是按照升序还是降序排列。 数组数字升序排序，例： 12let arr = [1, 2, 1, 2, 4, 4, 8, 0, 3, 4, 33, 45, 52, 42, 332, 3342, 33, 334,33, 3, 5, 55, 55, 88, 99 ];arr.sort((&#123;a, b&#125;) =&gt; a-b); 异步加载 JS 的方式 async async 属性是一个布尔值 async 属性一旦脚本可用，则立即异步执行 async 仅适用于外部脚本(只有在使用 src 属性时) Redux 的作用及优缺点 redux 让 state 的变化变得可预测、可回溯。 三个原则： 1. 单一数据源 2. state 是只读的 3. 使用纯函数来执行修改 Immutable 是一个可实现持续数据结构的 JavaScript 库。 跨域的解决方法 概念：只要协议、域名、端口有任何一个不同，都被当作是不同的域。 1、 JSONP JSONP 包含两部分：回调函数和数据。 回调函数是当响应到来时要放在当前页面被调用的函数。 数据就是传入回调函数中的 json 数据，也就是回调函数的参数了。 缺点： * 安全问题(请求代码中可能存在安全隐患) * 要确定 jsonp 请求是否失败并不容易 2、 跨域资源共享（CORS） CORS（Cross-Origin Resource Sharing）跨域资源共享，定义了必须在访问跨域资源时，浏览器与服务器应该如何沟通。 CORS背后的基本思想就是使用自定义的HTTP头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功还是失败。 3、 Web Sockets 一种浏览器 API ，它的目标是在一个单独的持久连接上提供全双工、双向通信。（同源策略不适用） 原理：在 js 创建了 web socket 之后，会有一个 HTTP 请求发送到浏览器以发起连接。 取得服务器响应后，建立的连接会使用 HTTP 升级从 HTTP 协议交换为 web sockt 协议。 只有在支持 web socket 协议的服务器上才能正常工作。 什么是服务端渲染？有什么好处？ 1、 首次加载页面更快。 2、 SEO 单页面（SPA）是什么？有什么优缺点？ 它将所有的活动局限于一个Web页面中，仅在该Web页面初始化时加载相应的HTML、JavaScript 和 CSS。一旦页面加载完成了，SPA不会因为用户的操作而进行页面的重新加载或跳转。取而代之的是利用 JavaScript 动态的变换HTML的内容，从而实现UI与用户的交互。由于避免了页面的重新加载，SPA 可以提供较为流畅的用户体验。 优点： 1、良好的交互体验 用户不需要从新刷新页面，获取数据也是通过 AJAX 异步获取，页面显示流畅 2、良好的前后端分离工作模式 单页Web应用可以和RESTful规约一起使用，通过REST API提供接口数据，并使用Ajax异步获取，这样有助于分离客户端和服务器端工作。更进一步，可以在客户端也可以分解为静态页面和页面交互两个部分。 3、减轻服务器压力 服务器只用出数据就可以，不用管展示逻辑和页面合成，吞吐能力会提高几倍； 4、公用一套后端程序代码 不用修改后端程序代码就可以同时用于Web界面、手机、平板等多种客户端； 缺点： 1、SEO 难度较高 由于所有的内容都在一个页面中动态替换显示，所以在SEO上其有着天然的弱势，所以如果你的站点对SEO很看重，且要用单页应用，那么就做些静态页面给搜索引擎用吧。 2、前进、后退管理 由于单页Web应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理，当然此问题也有解决方案，比如利用URI中的散列+iframe实现 3、初次加载耗时多 为实现单页Web应用功能及显示效果，需要在加载页面的时候将JavaScript、CSS统一加载，部分页面可以在需要的时候加载。所以必须对JavaScript及CSS代码进行合并压缩处理，如果使用第三方库，建议使用一些大公司的CDN，因此带宽的消耗是必然的。 常用 HTML 状态吗 状态码 含义 200 请求已成功，请求所希望的响应头或数据体将随此响应返回。 400 1、语义有误，当前请求无法被服务器理解。除非进行修改，否则客户端不应该重复提交这个请求。 2、请求参数有误。 403 服务器已经理解请求，但是拒绝执行它。 404 请求失败，请求所希望得到的资源未被在服务器上发现 500 服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。一般来说，这个问题都会在服务器的程序码出错时出现。 link 与 @import 的区别？ link 属于XHTML标签，而@import是css提供的. 页面在加载的时候，link会同时被加载；而@import引用的CSS会在页面加载完成后加载。 @import只在IE5以上才能生效；而link是XHTML标签，无兼容性问题. link方式引进的样式比 @import方式引进的样式权重高. 谈一下对HTML语义化的理解 html 语义化让页面的内容结构化，结构更清晰，便于浏览器、搜索引擎解析. 即使在没有样式的情况下也以一种文档格式显示，并且是容易阅读的. 搜索引擎的爬虫也依赖于HTML标记来确定上下文和各个关键字的权重，利于 SEO. 使阅读源码的人对网站更容易将网站分块，便以阅读维护理解.","tags":[{"name":"前端","slug":"前端","permalink":"maple13.github.io/tags/前端/"}]},{"title":"IE 条件语句","date":"2016-07-04T07:39:20.000Z","path":"2016/07/04/2016-07-04/","text":"用途 IE 条件语句包含在HTML注释语句中，只会被 IE 浏览器识别并执行，其他浏览器视其为HTML注释语句，于是全部被忽略，灵活使用IE 条件语句可以开发出兼容不同版本的IE浏览器的样式。 解析如果留意一下有些网站的源代码，有时会发现一些这样的代码：1234567&lt;!--[if IE5]&gt;&lt;style type=\"text/css\"&gt; /*将IE5*的CSS盒模型宽高计算修正放在这个条件注释中*/ #Test1 &#123; width: 180px; &#125; #Test2 &#123; width: 190px; &#125;&lt;/style&gt;&lt;![endif]--&gt; 或者1234567&lt;link href=\"css/index.css\" type=\"text/css\" /&gt;&lt;!--[if IE7]&gt;&lt;link href=\"css/ie7.css\" type=\"text/css\" /&gt;&lt;![endif]--&gt;&lt;!--[if IE6]&gt;&lt;link href=\"css/ie7.css\" type=\"text/css\" /&gt;&lt;![endif]--&gt; &lt;!– 和 –&gt;标识符配对使用表示HTML注释语句。但是IE会把这些特殊的注释语句当做一个简单的逻辑语句进行解析。 # 上面的第一段注释，表示如果当前浏览器是IE浏览器，则解析&lt;!–[if IE]&gt; 和 &lt;![endif]–&gt;标识符之间的样式表。而其他浏览器视而不见，当做注释语句全部忽略。因此可以在此放置一些能够兼容IE浏览器的样式代码。 在上面的第二段代码中，分别使用了不同的条件语句来设置不同版本的IE浏览器中链接不同的CSS文件，这样，不同版本的IE浏览器就可以导入不同的样式表，以实现兼容性。 IE条件语句的基本用法IE 条件语句一般放在HTML注释语句中，这样可以避免其他浏览器因为无法解析这些条件语句时可能出现的尴尬。其基本语法如下：123&lt;!--[if IE]&gt; IE 下可执行语句&lt;![endif]--&gt; 条件语句放在中括号内，然后嵌入到HTML注释中。注意，起始条件标记中省略了HTML注释语句的后半部分标记（– –&gt;），而结束标记中省略了HTML注释语句的前半部分标记（!– –），仅是一个半封闭的形式，这样对于其他浏览器来说，前后两个半封闭的HTML注释标记就形成了一个完整的注释标记，从而避免了由于其他浏览器无法解析的尴尬。 IE浏览器在解析HTML源码时，如果遇到类似&lt;!–[if IE]&gt;或&lt;![endif]–&gt;标记时，会立即解析其中包含的源代码。 在IE条件中可以放置一些简单的条件语句，或者设置成只能够在特定版本的浏览器中生效的源代码。 # 除了使用这些指定某种版本浏览器的条件语句之外，还可以结合 lte、lt、get、gt、！关键字来定义IE浏览器的版本范围，这些关键字的说明如下：``` ruby lte: 小于或等于某个版本的IE浏览器。 lt: 小于某个版本的IE浏览器。 gte： 大于或等于某个版本的IE浏览器。 gt： 大于某个版本的IE浏览器。 ！：不等于某个版本的IE浏览器。","tags":[{"name":"浏览器","slug":"浏览器","permalink":"maple13.github.io/tags/浏览器/"},{"name":"CSS","slug":"CSS","permalink":"maple13.github.io/tags/CSS/"}]},{"title":"Sublime Text 3 下编辑Markdown文件后在浏览器下自动刷新预览","date":"2016-06-22T08:08:20.000Z","path":"2016/06/22/2016-06-22/","text":"来源 近日在Sublime中编辑Markdown文件时想要实时预览一下,于是在网上寻找到了一种比较简单有效的方法，此方法来源于网上的Volcano大神，他的博客，他的GitHub地址。 安装Sublime Text 3 请前往Sublime Text官网下载Sublime软件并安装 下载插件 下载用于实时预览Markdown文件的Chrome插件。 使用Git方式下载 1$ git clone git://github.com/volca/markdown-preview.git Zip包下载 Chrome 网上应用店下载扩展 使用方法 找到上一步第一、二个方法下载的 markdown-preview 文件夹 开启chrome扩展的开发者模式，具体位置在 设置 -&gt; 扩展程序 里 加载已解压的扩展程序 将 允许访问文件网址 勾选上 然后你就可以尝试用chrome浏览器打开markdown文件预览了，采用趁手的编辑器去修改它。它会在浏览器自动刷新！","tags":[{"name":"Sublime","slug":"Sublime","permalink":"maple13.github.io/tags/Sublime/"}]},{"title":"Hello World！","date":"2015-09-17T08:22:52.000Z","path":"2015/09/17/Hello-world/","text":"Welcome to Hexo! 以下是Hexo的一些常用命令，如果需要详细了解,可以前往 documentation 查询详细文档. 如果你在使用Hexo时出现问题，你可以在troubleshooting搜索答案,或者可以前往Hexo的GitHub上提出问题. 快速开始创建一个新的文章1$ hexo new \"My New Post\" More info: Writing 运行服务1$ hexo server More info: Server 生成静态文件1$ hexo generate More info: Generating 部署到远程站点1$ hexo deploy More info: Deployment","tags":[{"name":"随笔","slug":"随笔","permalink":"maple13.github.io/tags/随笔/"}]}]