<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>枫小生的博客</title>
  <subtitle>自己认为的很努力，对比别人只是表面上的努力而已！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="maple13.github.io/"/>
  <updated>2017-07-24T17:00:34.000Z</updated>
  <id>maple13.github.io/</id>
  
  <author>
    <name>Maple13</name>
    <email>Mr_daijc@163.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>React-redux 初识</title>
    <link href="maple13.github.io/2017/07/25/2017-07-25/"/>
    <id>maple13.github.io/2017/07/25/2017-07-25/</id>
    <published>2017-07-24T16:58:10.000Z</published>
    <updated>2017-07-24T17:00:34.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>React-redux 对外提供的 API 有四个：<code>Provider</code>/<code>createProvider</code>/<code>connectAdvanced</code>/<code>connect</code></p>
</blockquote>
<h3 id="connectAdvanced"><a href="#connectAdvanced" class="headerlink" title="connectAdvanced"></a><code>connectAdvanced</code></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">connectAdvanced(selectorFactory, [connectOptions])</div></pre></td></tr></table></figure>
<a id="more"></a>
<blockquote>
<p><code>connectAdvanced</code> 用来连接组件到 <code>Redux</code> 的 <code>store</code> 上。是 <code>connect</code> 函数的基础，但并没有规定如果将 <code>state</code> 、<code>props</code> 、 <code>dispatch</code> 处理传入最终的 <code>props</code> 中。</p>
<p> <code>connectAdvanced</code> 并没有对产生的 <code>props</code> 做缓存来优化性能，都留给了调用者去实现。<br> <code>connectAdvanced</code> 并没有修改传入的组件类，而是返回一个新的、连接到 <code>store</code> 的组件类。</p>
</blockquote>
<p>返回：</p>
<blockquote>
<p>函数返回一个高阶组件，该高阶组件将从 store 的 state 中构建的 props 传递给被包裹组件。</p>
</blockquote>
<h3 id="Provider"><a href="#Provider" class="headerlink" title="Provider"></a><code>Provider</code></h3><blockquote>
<p><code>Provider</code> 使组件层级中的 <code>connect()</code> 方法都能获取到 <code>Redux Store</code> 。<br>正常情况下，你的根组件应该嵌套在 <code>&lt;Provider&gt;</code> 中才能使用 <code>connect()</code> 方法。</p>
<p>如果你真的不想把根组件嵌套在 <code>&lt;Provider&gt;</code> 中，你可以把 <code>store</code> 作为 <code>props</code> 传递到每一个被 <code>connet()</code> 包装的组件，但是我们只推荐您在单元测试中对 <code>store</code> 进行伪造 (stub) 或者在非完全基于 React 的代码中才这样做。<br>正常情况下，你应该使用 <code>&lt;Provider&gt;</code>。</p>
</blockquote>
<h3 id="connect"><a href="#connect" class="headerlink" title="connect()"></a><code>connect()</code></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">connect([mapStateToProps], [mapDispatchToProps], [mergeProps], [options])</div></pre></td></tr></table></figure>
<blockquote>
<p>连接 React 组件与 Redux store。<br>连接操作不会改变原来的组件类。<br>反而返回一个新的与 Redux store 连接的组件类。</p>
</blockquote>
<p>返回值：</p>
<blockquote>
<p>根据配置信息，返回一个注入了 state 和 action creator 的 React 组件。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;React-redux 对外提供的 API 有四个：&lt;code&gt;Provider&lt;/code&gt;/&lt;code&gt;createProvider&lt;/code&gt;/&lt;code&gt;connectAdvanced&lt;/code&gt;/&lt;code&gt;connect&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;connectAdvanced&quot;&gt;&lt;a href=&quot;#connectAdvanced&quot; class=&quot;headerlink&quot; title=&quot;connectAdvanced&quot;&gt;&lt;/a&gt;&lt;code&gt;connectAdvanced&lt;/code&gt;&lt;/h3&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;connectAdvanced(selectorFactory, [connectOptions])&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="React" scheme="maple13.github.io/tags/React/"/>
    
      <category term="React-redux" scheme="maple13.github.io/tags/React-redux/"/>
    
  </entry>
  
  <entry>
    <title>React 数据流与组件间通信</title>
    <link href="maple13.github.io/2017/07/24/2017-07-24-1/"/>
    <id>maple13.github.io/2017/07/24/2017-07-24-1/</id>
    <published>2017-07-24T14:47:25.000Z</published>
    <updated>2017-07-24T14:51:37.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="单向数据流"><a href="#单向数据流" class="headerlink" title="单向数据流"></a>单向数据流</h3><blockquote>
<p><code>React</code> 是单向数据流，数据主要从父节点传递到子节点（通过Props）。<br>如果顶层的某个 <code>Props</code> 改变了，<code>React</code> 就会重新渲染所有的相关子节点。</p>
</blockquote>
<a id="more"></a>
<h3 id="组件间通信"><a href="#组件间通信" class="headerlink" title="组件间通信"></a>组件间通信</h3><ol>
<li><p>父子组件通信<br> 在 <code>React</code> 中，最常见的组件通信就是父子了，一般：</p>
<blockquote>
<p>父组件更新组件状态 –&gt; Prosp –&gt; 子组件更新</p>
<p>子组件更新父组件状态 –&gt; 需要父组件传递回调函数 –&gt; 子组件调用触发</p>
</blockquote>
<p> <a href="https://codepen.io/Maple13/pen/awrobR" target="_blank" rel="external">父子组件通信示例 . codepen</a></p>
</li>
<li><p>兄弟组件通信</p>
<ul>
<li><p>方式一：<br>  在两个组件处于同一级时（同处父级，或者同处子级），就称为兄弟组件<br>  。</p>
<blockquote>
<p>按照 <code>React</code> 单向数据流方式，我们需要借助父组件进行传递，通过 <code>父组件回调函数</code> 改变兄弟组件的 <code>Props</code> .</p>
<p>其实这种实现方式与子组件更新父组件状态的方式是大同小异的。</p>
</blockquote>
</li>
<li><p>方式二：</p>
<blockquote>
<p>方式一只适用于组件层次很少的情况下，当组件层次很深的时候，整个通信的效率就会变得很低。</p>
<p>React 官方给我们提供了一种上下文方式，可以让子组件直接访问祖先组件的数据或函数，无需从祖先组件一层层传递数据到子组件中。</p>
<p>但这种方式建议按需使用，可能导致一些不可预期的错误（比如数据传递逻辑结构不清晰）。</p>
</blockquote>
</li>
</ul>
</li>
</ol>
<blockquote>
<p>本文借鉴<a href="https://segmentfault.com/a/1190000006831820#articleHeader6" target="_blank" rel="external"><code>Samo</code></a>文章</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;单向数据流&quot;&gt;&lt;a href=&quot;#单向数据流&quot; class=&quot;headerlink&quot; title=&quot;单向数据流&quot;&gt;&lt;/a&gt;单向数据流&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;React&lt;/code&gt; 是单向数据流，数据主要从父节点传递到子节点（通过Props）。&lt;br&gt;如果顶层的某个 &lt;code&gt;Props&lt;/code&gt; 改变了，&lt;code&gt;React&lt;/code&gt; 就会重新渲染所有的相关子节点。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="React" scheme="maple13.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>React 理解集锦</title>
    <link href="maple13.github.io/2017/07/24/2017-07-24/"/>
    <id>maple13.github.io/2017/07/24/2017-07-24/</id>
    <published>2017-07-24T04:16:11.000Z</published>
    <updated>2017-07-24T04:20:03.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="React-生命周期常用方法"><a href="#React-生命周期常用方法" class="headerlink" title="React 生命周期常用方法"></a>React 生命周期常用方法</h2><p>实例化：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">componentWillMount</span><span class="params">()</span></span></div><div class="line"><span class="function"><span class="title">render</span><span class="params">()</span></span></div><div class="line"><span class="function"><span class="title">componentDidMount</span><span class="params">()</span></span></div></pre></td></tr></table></figure>
<a id="more"></a>
<p>存在期：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">componentWillReceiveProps</span><span class="params">()</span></span></div><div class="line"><span class="function"><span class="title">shouldComponentUpdate</span><span class="params">()</span></span></div><div class="line"><span class="function"><span class="title">componentWillUpdate</span><span class="params">()</span></span></div><div class="line"><span class="function"><span class="title">render</span><span class="params">()</span></span></div><div class="line"><span class="function"><span class="title">componentDidMount</span><span class="params">()</span></span></div></pre></td></tr></table></figure>
<p>销毁期：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">componentWillUnmount</span><span class="params">()</span></span></div></pre></td></tr></table></figure>
<h2 id="React-中-Element-与-Component-的区别？"><a href="#React-中-Element-与-Component-的区别？" class="headerlink" title="React 中 Element 与 Component 的区别？"></a>React 中 <code>Element</code> 与 <code>Component</code> 的区别？</h2><p>简单而言，<code>React Element</code> 是描述屏幕上所见内容的数据结构，是对于 UI 的对象表述。典型的 <code>React Element</code> 就是利用 <code>JSX</code> 构建的声明式代码片然后被转化为 <code>createElement</code> 的调用组合。而 <code>React Component</code> 则是可以接收参数输入并且返回某个 <code>React Element</code> 的函数或者类。</p>
<h2 id="在什么情况下会优先使用-Class-Component-而不是-Functional-Component"><a href="#在什么情况下会优先使用-Class-Component-而不是-Functional-Component" class="headerlink" title="在什么情况下会优先使用 Class Component 而不是 Functional Component"></a>在什么情况下会优先使用 <code>Class Component</code> 而不是 <code>Functional Component</code></h2><blockquote>
<p>在组件需要包含内部状态或者使用到生命周期函数的时候使用 <code>Class Component</code> ，否则使用函数式组件。</p>
</blockquote>
<h2 id="React-中-refs-的作用是什么？"><a href="#React-中-refs-的作用是什么？" class="headerlink" title="React 中 refs 的作用是什么？"></a>React 中 <code>refs</code> 的作用是什么？</h2><blockquote>
<p><code>Refs</code> 是 React 提供给我们的安全访问 DOM 元素或者某个组件实例的句柄。我们可以为元素添加 <code>ref</code> 属性然后在回调函数中接受该元素在 DOM 树中的句柄，该值会作为回调函数的第一个参数返回.</p>
</blockquote>
<h2 id="在生命周期中的哪一步应该发起-AJAX-请求？"><a href="#在生命周期中的哪一步应该发起-AJAX-请求？" class="headerlink" title="在生命周期中的哪一步应该发起 AJAX 请求？"></a>在生命周期中的哪一步应该发起 <code>AJAX</code> 请求？</h2><p>我们应该将 <code>AJAX</code> 请求放在 <code>componentDidMount</code> 函数中执行，主要原因是：</p>
<blockquote>
<p>React 下一代调和算法 <code>Fiber</code> 会通过开始或停止渲染的方式优化应用性能，其会影响到 <code>componentWillMount</code> 的触发次数。<br>    对于 <code>componentWillMount</code> 这个生命周期函数的调用次数会变得不确定，React 可以会多次频繁调用 <code>componentWillMount</code> 。如果我们将 AJAX 请求放在 <code>componentWillMount</code> 函数中，那么显而易见其会被触发多次，自然不是好选择。</p>
<p>如果我们将 AJAX 请求放置在生命周期的其他函数中，我们并不能保证请求仅在组件挂载完毕后才会要求响应。如果我们的数据请求在组件挂载之前就完成，并且调用了setState函数将数据添加到组件状态中，对于未挂载的组件则会报错。<br>而在 componentDidMount 函数中进行 AJAX 请求则能有效避免这个问题。</p>
</blockquote>
<h2 id="shouldComponentUpdate-的作用是啥以及为何它这么重要？"><a href="#shouldComponentUpdate-的作用是啥以及为何它这么重要？" class="headerlink" title="shouldComponentUpdate 的作用是啥以及为何它这么重要？"></a><code>shouldComponentUpdate</code> 的作用是啥以及为何它这么重要？</h2><blockquote>
<p><code>shouldComponentUpdate</code> 允许我们手动的判断是否要进行组件更新，根据组件的应用场景设置函数的合理返回值能够帮我们避免不必要的更新。</p>
</blockquote>
<h2 id="React-中的事件处理逻辑"><a href="#React-中的事件处理逻辑" class="headerlink" title="React 中的事件处理逻辑"></a>React 中的事件处理逻辑</h2><blockquote>
<p>为了解决跨浏览器兼容性问题，React 会将浏览器原生事件封装为合成事件传入设置的事件处理器中。这里的合成事件提供了与原生事件相同的接口，不过它们屏蔽了底层浏览器的细节差异，保证了行为的一致性。另外有意思的是，React 并没有直接将事件附着到子元素上，而是以单一事件监听器的方式将所有的事件发送到顶层进行处理。这样 React 在更新 DOM 的时候就不需要考虑如何去处理附着在 DOM 上的事件监听器，最终达到优化性能的目的。</p>
</blockquote>
<h2 id="createElement-与-cloneElement-的区别是什么？"><a href="#createElement-与-cloneElement-的区别是什么？" class="headerlink" title="createElement 与 cloneElement 的区别是什么？"></a><code>createElement</code> 与 <code>cloneElement</code> 的区别是什么？</h2><blockquote>
<p><code>createElement</code> 函数是 <code>JSX</code> 编译之后使用的创建 React Element 的函数，而 <code>cloneElement</code> 则是用于复制某个元素并传入新的 <code>Props</code> 。</p>
</blockquote>
<h2 id="传入-setState-函数的第二个参数的作用是什么？"><a href="#传入-setState-函数的第二个参数的作用是什么？" class="headerlink" title="传入 setState 函数的第二个参数的作用是什么？"></a>传入 <code>setState</code> 函数的第二个参数的作用是什么？</h2><blockquote>
<p>该函数会在 <code>setState</code> 函数调用完成并且组件开始重新渲染的时候被调用，我们可以用该函数来监听渲染是否完成。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;React-生命周期常用方法&quot;&gt;&lt;a href=&quot;#React-生命周期常用方法&quot; class=&quot;headerlink&quot; title=&quot;React 生命周期常用方法&quot;&gt;&lt;/a&gt;React 生命周期常用方法&lt;/h2&gt;&lt;p&gt;实例化：&lt;/p&gt;
&lt;figure class=&quot;highlight stylus&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;componentWillMount&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;render&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;componentDidMount&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="React" scheme="maple13.github.io/tags/React/"/>
    
      <category term="面试题" scheme="maple13.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>前端常见知识归纳</title>
    <link href="maple13.github.io/2017/07/19/2017-07-19/"/>
    <id>maple13.github.io/2017/07/19/2017-07-19/</id>
    <published>2017-07-19T09:35:55.000Z</published>
    <updated>2017-07-19T10:23:15.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是伪数组？如何将其转化为标准数组？"><a href="#什么是伪数组？如何将其转化为标准数组？" class="headerlink" title="什么是伪数组？如何将其转化为标准数组？"></a>什么是伪数组？如何将其转化为标准数组？</h2><ul>
<li><p>什么是伪数组（类数组）：</p>
<p>  无法直接调用数组方法或期望 <code>length</code> 属性有什么特殊的行为，但仍可以使用真正数组遍历方法遍历它们。<br>典型的就是 <code>arguments</code> 参数，还有像调用 <code>getElementsByTagName / document.childNodes</code>之类方法，它们都返回的 <code>NodeList</code> 对象都属于伪数组。</p>
</li>
</ul>
<a id="more"></a>
<ul>
<li><p>如何转换为标准数组？</p>
<p>可以使用<code>Array.prototype.slice.call(fakeArray)</code>将伪数组转换为真正的Array对象。<br>但对于<code>NodeList</code>则不行，其在IE8下会报错，只能是JS引擎有所限制。因此，如果需要把 NodeList 转换为标准数组，就需要做向下兼容：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">realArray</span>(<span class="params">arr</span>) </span>&#123;</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">Array</span>.prototype.slice.call(arr);</div><div class="line">  &#125; <span class="keyword">catch</span> &#123;</div><div class="line">    <span class="keyword">var</span> ret = [], len = arr.length;</div><div class="line">    <span class="keyword">for</span> (; i &lt; len; i++) &#123;</div><div class="line">      ret[i] = (c[i]);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> ret;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>方法二：使用ES6 数组扩展的 form() 方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>);</div></pre></td></tr></table></figure>
<p>伪数组转换为标准数组的条件：</p>
<blockquote>
<p>1、伪数组的键值需要为数字，否则转换后数组均无初始值<br>  2、有 length 属性</p>
</blockquote>
</li>
</ul>
<h2 id="数组去重与排序"><a href="#数组去重与排序" class="headerlink" title="数组去重与排序"></a>数组去重与排序</h2><ol>
<li><p>去重之一：创建一个新数组，使用 <code>indexOf</code> 判断新数组中是否存在值，例：</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"> <span class="keyword">const</span> dedupOne = <span class="function"><span class="params">arr</span> =&gt;</span> &#123;</div><div class="line">    <span class="keyword">let</span> ret = [];</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = arr.length; i &lt; len; i++) &#123;</div><div class="line">        <span class="keyword">if</span> (ret.indexOf(arr[i) === <span class="number">-1</span>) &#123;</div><div class="line">            ret.push(arr[i]);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> ret;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>去重之二：创建一个新对象</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> dedupTwo = arr = &gt; &#123;</div><div class="line">    <span class="keyword">let</span> hash = &#123;&#125;,</div><div class="line">        len  = arr.length,</div><div class="line">        ret  = [];</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</div><div class="line">        <span class="keyword">if</span> (!hash[arr[i]]) &#123;</div><div class="line">            hash[arr[i]] = arr[i];</div><div class="line">            ret.push(arr[i]);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> ret;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>数组排序</p>
 <figure class="highlight markdown"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">一般使用 Array 的原生方法 sort() 方法排序。</div><div class="line"><span class="bullet">1. </span>排序顺序可以是字母和数字，并按升序或降序。</div><div class="line"><span class="bullet">2. </span>默认排序是字母升序。</div><div class="line"><span class="bullet">3. </span>在原始数组上排序，不会生成数组副本。</div><div class="line"></div><div class="line">使用数字排序，你必须通过一个函数作为参数来调用。</div><div class="line">函数指定数字是按照升序还是降序排列。</div></pre></td></tr></table></figure>
<p> 数组数字升序排序，例：</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> arr =  [<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">33</span>, <span class="number">45</span>, <span class="number">52</span>, <span class="number">42</span>, <span class="number">332</span>, <span class="number">3342</span>, <span class="number">33</span>, <span class="number">334</span>,<span class="number">33</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">55</span>, <span class="number">55</span>, <span class="number">88</span>, <span class="number">99</span> ];</div><div class="line">arr.sort(<span class="function">(<span class="params">&#123;a, b&#125;</span>) =&gt;</span> a-b);</div></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="异步加载-JS-的方式"><a href="#异步加载-JS-的方式" class="headerlink" title="异步加载 JS 的方式"></a>异步加载 JS 的方式</h2><ol>
<li><p><code>async</code></p>
<blockquote>
<ol>
<li>async 属性是一个布尔值<ol>
<li>async 属性一旦脚本可用，则立即异步执行</li>
<li>async 仅适用于外部脚本(只有在使用 src 属性时)</li>
</ol>
</li>
</ol>
</blockquote>
</li>
</ol>
<h2 id="Redux-的作用及优缺点"><a href="#Redux-的作用及优缺点" class="headerlink" title="Redux 的作用及优缺点"></a>Redux 的作用及优缺点</h2><p>  <code>redux</code> 让 <code>state</code> 的变化变得可预测、可回溯。</p>
<blockquote>
<p>三个原则：</p>
<pre><code>1. 单一数据源
2. state 是只读的
3. 使用纯函数来执行修改
</code></pre></blockquote>
<p>  <code>Immutable</code> 是一个可实现持续数据结构的 JavaScript 库。</p>
<h2 id="跨域的解决方法"><a href="#跨域的解决方法" class="headerlink" title="跨域的解决方法"></a>跨域的解决方法</h2><blockquote>
<p>概念：只要协议、域名、端口有任何一个不同，都被当作是不同的域。</p>
</blockquote>
<p>  1、 JSONP</p>
<blockquote>
<p> JSONP 包含两部分：回调函数和数据。<br>    回调函数是当响应到来时要放在当前页面被调用的函数。<br>    数据就是传入回调函数中的 json 数据，也就是回调函数的参数了。<br>    缺点：</p>
<pre><code>* 安全问题(请求代码中可能存在安全隐患)
* 要确定 jsonp 请求是否失败并不容易
</code></pre></blockquote>
<p>  2、 跨域资源共享（CORS）</p>
<blockquote>
<p> CORS（Cross-Origin Resource Sharing）跨域资源共享，定义了必须在访问跨域资源时，浏览器与服务器应该如何沟通。<br>      CORS背后的基本思想就是使用自定义的HTTP头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功还是失败。</p>
</blockquote>
<p>  3、 Web Sockets</p>
<blockquote>
<p>   一种浏览器 API ，它的目标是在一个单独的持久连接上提供全双工、双向通信。（同源策略不适用）<br>      原理：在 js 创建了 web socket 之后，会有一个 HTTP 请求发送到浏览器以发起连接。<br>        取得服务器响应后，建立的连接会使用 HTTP 升级从 HTTP 协议交换为 web sockt 协议。<br>      只有在支持 web socket 协议的服务器上才能正常工作。</p>
</blockquote>
<h2 id="什么是服务端渲染？有什么好处？"><a href="#什么是服务端渲染？有什么好处？" class="headerlink" title="什么是服务端渲染？有什么好处？"></a>什么是服务端渲染？有什么好处？</h2><blockquote>
<p>1、 首次加载页面更快。<br>  2、 SEO</p>
</blockquote>
<h2 id="单页面（SPA）是什么？有什么优缺点？"><a href="#单页面（SPA）是什么？有什么优缺点？" class="headerlink" title="单页面（SPA）是什么？有什么优缺点？"></a>单页面（SPA）是什么？有什么优缺点？</h2><blockquote>
<p>它将所有的活动局限于一个Web页面中，仅在该Web页面初始化时加载相应的HTML、JavaScript 和 CSS。一旦页面加载完成了，SPA不会因为用户的操作而进行页面的重新加载或跳转。取而代之的是利用 JavaScript 动态的变换HTML的内容，从而实现UI与用户的交互。由于避免了页面的重新加载，SPA 可以提供较为流畅的用户体验。</p>
</blockquote>
<p>优点：</p>
<blockquote>
<p>1、良好的交互体验<br>    用户不需要从新刷新页面，获取数据也是通过 AJAX 异步获取，页面显示流畅<br>  2、良好的前后端分离工作模式<br>    单页Web应用可以和RESTful规约一起使用，通过REST API提供接口数据，并使用Ajax异步获取，这样有助于分离客户端和服务器端工作。更进一步，可以在客户端也可以分解为静态页面和页面交互两个部分。<br>  3、减轻服务器压力<br>    服务器只用出数据就可以，不用管展示逻辑和页面合成，吞吐能力会提高几倍；<br>  4、公用一套后端程序代码<br>    不用修改后端程序代码就可以同时用于Web界面、手机、平板等多种客户端；</p>
</blockquote>
<p>缺点：</p>
<blockquote>
<p>1、SEO 难度较高<br>    由于所有的内容都在一个页面中动态替换显示，所以在SEO上其有着天然的弱势，所以如果你的站点对SEO很看重，且要用单页应用，那么就做些静态页面给搜索引擎用吧。<br>  2、前进、后退管理<br>    由于单页Web应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理，当然此问题也有解决方案，比如利用URI中的散列+iframe实现<br>  3、初次加载耗时多<br>    为实现单页Web应用功能及显示效果，需要在加载页面的时候将JavaScript、CSS统一加载，部分页面可以在需要的时候加载。所以必须对JavaScript及CSS代码进行合并压缩处理，如果使用第三方库，建议使用一些大公司的CDN，因此带宽的消耗是必然的。</p>
</blockquote>
<h2 id="常用-HTML-状态吗"><a href="#常用-HTML-状态吗" class="headerlink" title="常用 HTML 状态吗"></a>常用 <code>HTML</code> 状态吗</h2><table>
<thead>
<tr>
<th>状态码</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>200</td>
<td>请求已成功，请求所希望的响应头或数据体将随此响应返回。</td>
</tr>
<tr>
<td>400</td>
<td>1、语义有误，当前请求无法被服务器理解。除非进行修改，否则客户端不应该重复提交这个请求。    2、请求参数有误。</td>
</tr>
<tr>
<td>403</td>
<td>服务器已经理解请求，但是拒绝执行它。</td>
</tr>
<tr>
<td>404</td>
<td>请求失败，请求所希望得到的资源未被在服务器上发现</td>
</tr>
<tr>
<td>500</td>
<td>服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。一般来说，这个问题都会在服务器的程序码出错时出现。</td>
</tr>
</tbody>
</table>
<h2 id="link-与-import-的区别？"><a href="#link-与-import-的区别？" class="headerlink" title="link 与 @import 的区别？"></a><code>link</code> 与 <code>@import</code> 的区别？</h2><blockquote>
<ol>
<li><code>link</code> 属于<code>XHTML</code>标签，而<code>@import</code>是<code>css</code>提供的.</li>
<li>页面在加载的时候，<code>link</code>会同时被加载；而<code>@import</code>引用的<code>CSS</code>会在页面加载完成后加载。</li>
<li><code>@import</code>只在<code>IE5</code>以上才能生效；而<code>link</code>是<code>XHTML</code>标签，无兼容性问题.</li>
<li><code>link</code>方式引进的样式比 <code>@import</code>方式引进的样式权重高.</li>
</ol>
</blockquote>
<h2 id="谈一下对HTML语义化的理解"><a href="#谈一下对HTML语义化的理解" class="headerlink" title="谈一下对HTML语义化的理解"></a>谈一下对<code>HTML</code>语义化的理解</h2><blockquote>
<ol>
<li><code>html</code> 语义化让页面的内容结构化，结构更清晰，便于浏览器、搜索引擎解析.</li>
<li>即使在没有样式的情况下也以一种文档格式显示，并且是容易阅读的.</li>
<li>搜索引擎的爬虫也依赖于<code>HTML</code>标记来确定上下文和各个关键字的权重，利于 <code>SEO</code>.</li>
<li>使阅读源码的人对网站更容易将网站分块，便以阅读维护理解.</li>
</ol>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是伪数组？如何将其转化为标准数组？&quot;&gt;&lt;a href=&quot;#什么是伪数组？如何将其转化为标准数组？&quot; class=&quot;headerlink&quot; title=&quot;什么是伪数组？如何将其转化为标准数组？&quot;&gt;&lt;/a&gt;什么是伪数组？如何将其转化为标准数组？&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;什么是伪数组（类数组）：&lt;/p&gt;
&lt;p&gt;  无法直接调用数组方法或期望 &lt;code&gt;length&lt;/code&gt; 属性有什么特殊的行为，但仍可以使用真正数组遍历方法遍历它们。&lt;br&gt;典型的就是 &lt;code&gt;arguments&lt;/code&gt; 参数，还有像调用 &lt;code&gt;getElementsByTagName / document.childNodes&lt;/code&gt;之类方法，它们都返回的 &lt;code&gt;NodeList&lt;/code&gt; 对象都属于伪数组。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="前端" scheme="maple13.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>IE 条件语句</title>
    <link href="maple13.github.io/2016/07/04/2016-07-04/"/>
    <id>maple13.github.io/2016/07/04/2016-07-04/</id>
    <published>2016-07-04T07:39:20.000Z</published>
    <updated>2016-07-04T09:11:52.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><blockquote>
<p>IE 条件语句包含在HTML注释语句中，只会被 IE 浏览器识别并执行，其他浏览器视其为HTML注释语句，于是全部被忽略，灵活使用IE 条件语句可以开发出兼容不同版本的IE浏览器的样式。</p>
</blockquote>
<a id="more"></a>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>如果留意一下有些网站的源代码，有时会发现一些这样的代码：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;!--[<span class="keyword">if</span> IE5]&gt;</div><div class="line">&lt;style <span class="built_in">type</span>=<span class="string">"text/css"</span>&gt;</div><div class="line">    /*将IE5*的CSS盒模型宽高计算修正放在这个条件注释中*/</div><div class="line">    <span class="comment">#Test1 &#123; width: 180px; &#125;</span></div><div class="line">    <span class="comment">#Test2 &#123; width: 190px; &#125;</span></div><div class="line">&lt;/style&gt;</div><div class="line">&lt;![endif]--&gt;</div></pre></td></tr></table></figure></p>
<p>或者<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;link href=<span class="string">"css/index.css"</span> <span class="built_in">type</span>=<span class="string">"text/css"</span> /&gt;</div><div class="line">&lt;!--[<span class="keyword">if</span> IE7]&gt;</div><div class="line">&lt;link href=<span class="string">"css/ie7.css"</span> <span class="built_in">type</span>=<span class="string">"text/css"</span> /&gt;</div><div class="line">&lt;![endif]--&gt;</div><div class="line">&lt;!--[<span class="keyword">if</span> IE6]&gt;</div><div class="line">&lt;link href=<span class="string">"css/ie7.css"</span> <span class="built_in">type</span>=<span class="string">"text/css"</span> /&gt;</div><div class="line">&lt;![endif]--&gt;</div></pre></td></tr></table></figure></p>
<blockquote>
<p><em>&lt;!–</em> 和 <em>–&gt;</em>标识符配对使用表示HTML注释语句。但是IE会把这些特殊的注释语句当做一个简单的逻辑语句进行解析。</p>
</blockquote>
<p>#</p>
<blockquote>
<ul>
<li><p>上面的第一段注释，表示如果当前浏览器是IE浏览器，则解析<em>&lt;!–[if IE]&gt;</em> 和 <em>&lt;![endif]–&gt;</em>标识符之间的样式表。而其他浏览器视而不见，当做注释语句全部忽略。因此可以在此放置一些能够兼容IE浏览器的样式代码。</p>
</li>
<li><p>在上面的第二段代码中，分别使用了不同的条件语句来设置不同版本的IE浏览器中链接不同的CSS文件，这样，不同版本的IE浏览器就可以导入不同的样式表，以实现兼容性。</p>
</li>
</ul>
</blockquote>
<h2 id="IE条件语句的基本用法"><a href="#IE条件语句的基本用法" class="headerlink" title="IE条件语句的基本用法"></a>IE条件语句的基本用法</h2><p>IE 条件语句一般放在HTML注释语句中，这样可以避免其他浏览器因为无法解析这些条件语句时可能出现的尴尬。其基本语法如下：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;!--[<span class="keyword">if</span> IE]&gt;</div><div class="line">    IE 下可执行语句</div><div class="line">&lt;![endif]--&gt;</div></pre></td></tr></table></figure></p>
<blockquote>
<ul>
<li>条件语句放在中括号内，然后嵌入到HTML注释中。注意，起始条件标记中省略了HTML注释语句的后半部分标记（– –&gt;），而结束标记中省略了HTML注释语句的前半部分标记（!– –），仅是一个半封闭的形式，这样对于其他浏览器来说，前后两个半封闭的HTML注释标记就形成了一个完整的注释标记，从而避免了由于其他浏览器无法解析的尴尬。</li>
<li>IE浏览器在解析HTML源码时，如果遇到类似<em>&lt;!–[if IE]&gt;</em>或<em>&lt;![endif]–&gt;</em>标记时，会立即解析其中包含的源代码。</li>
<li>在IE条件中可以放置一些简单的条件语句，或者设置成只能够在特定版本的浏览器中生效的源代码。</li>
</ul>
</blockquote>
<p>#</p>
<blockquote>
<p>除了使用这些指定某种版本浏览器的条件语句之外，还可以结合 <strong>lte、lt、get、gt、！</strong>关键字来定义IE浏览器的版本范围，这些关键字的说明如下：<br>``` ruby</p>
<ul>
<li>lte: 小于或等于某个版本的IE浏览器。</li>
<li>lt: 小于某个版本的IE浏览器。</li>
<li>gte： 大于或等于某个版本的IE浏览器。</li>
<li>gt： 大于某个版本的IE浏览器。</li>
<li>！：不等于某个版本的IE浏览器。</li>
</ul>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;用途&quot;&gt;&lt;a href=&quot;#用途&quot; class=&quot;headerlink&quot; title=&quot;用途&quot;&gt;&lt;/a&gt;用途&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;IE 条件语句包含在HTML注释语句中，只会被 IE 浏览器识别并执行，其他浏览器视其为HTML注释语句，于是全部被忽略，灵活使用IE 条件语句可以开发出兼容不同版本的IE浏览器的样式。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="浏览器" scheme="maple13.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
      <category term="CSS" scheme="maple13.github.io/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>Sublime Text 3 下编辑Markdown文件后在浏览器下自动刷新预览</title>
    <link href="maple13.github.io/2016/06/22/2016-06-22/"/>
    <id>maple13.github.io/2016/06/22/2016-06-22/</id>
    <published>2016-06-22T08:08:20.000Z</published>
    <updated>2016-06-29T03:43:50.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h2><blockquote>
<p>近日在Sublime中编辑Markdown文件时想要实时预览一下,于是在网上寻找到了一种比较简单有效的方法，此方法来源于网上的Volcano大神，他的<a href="http://www.ooso.net/archives/611" target="_blank" rel="external">博客</a>，他的<a href="https://github.com/volca/markdown-preview" target="_blank" rel="external">GitHub</a>地址。</p>
</blockquote>
<a id="more"></a>
<h3 id="安装Sublime-Text-3"><a href="#安装Sublime-Text-3" class="headerlink" title="安装Sublime Text 3"></a>安装Sublime Text 3</h3><blockquote>
<ul>
<li>请前往<a href="http://www.sublimetext.com/" target="_blank" rel="external">Sublime Text</a>官网下载Sublime软件并安装</li>
</ul>
</blockquote>
<h3 id="下载插件"><a href="#下载插件" class="headerlink" title="下载插件"></a>下载插件</h3><blockquote>
<p>下载用于实时预览Markdown文件的Chrome插件。</p>
<ul>
<li><p>使用Git方式下载</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git <span class="built_in">clone</span> git://github.com/volca/markdown-preview.git</div></pre></td></tr></table></figure>
</li>
<li><p>Zip包<a href="https://github.com/volca/markdown-preview/archive/master.zip" target="_blank" rel="external">下载</a></p>
</li>
<li><a href="https://chrome.google.com/webstore/detail/markdown-preview-plus/febilkbfcbhebfnokafefeacimjdckgl" target="_blank" rel="external">Chrome 网上应用店下载扩展</a></li>
</ul>
</blockquote>
<h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><blockquote>
<ol>
<li>找到上一步第一、二个方法下载的<strong> markdown-preview </strong>文件夹</li>
<li>开启chrome扩展的开发者模式，具体位置在<strong> 设置 </strong> -&gt; <strong> 扩展程序 </strong>里</li>
<li><strong> 加载已解压的扩展程序 </strong></li>
<li>将<strong> 允许访问文件网址 </strong>勾选上</li>
</ol>
<p>然后你就可以尝试用chrome浏览器打开markdown文件预览了，采用趁手的编辑器去修改它。它会在浏览器自动刷新！</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;来源&quot;&gt;&lt;a href=&quot;#来源&quot; class=&quot;headerlink&quot; title=&quot;来源&quot;&gt;&lt;/a&gt;来源&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;近日在Sublime中编辑Markdown文件时想要实时预览一下,于是在网上寻找到了一种比较简单有效的方法，此方法来源于网上的Volcano大神，他的&lt;a href=&quot;http://www.ooso.net/archives/611&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;博客&lt;/a&gt;，他的&lt;a href=&quot;https://github.com/volca/markdown-preview&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;GitHub&lt;/a&gt;地址。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Sublime" scheme="maple13.github.io/tags/Sublime/"/>
    
  </entry>
  
  <entry>
    <title>Hello World！</title>
    <link href="maple13.github.io/2015/09/17/Hello-world/"/>
    <id>maple13.github.io/2015/09/17/Hello-world/</id>
    <published>2015-09-17T08:22:52.000Z</published>
    <updated>2016-06-27T02:09:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="http://hexo.io/" target="_blank" rel="external">Hexo</a>! 以下是Hexo的一些常用命令，如果需要详细了解,可以前往 <a href="http://hexo.io/docs/" target="_blank" rel="external">documentation</a> 查询详细文档. 如果你在使用Hexo时出现问题，你可以在<a href="http://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a>搜索答案,或者可以前往Hexo的<a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>上提出问题.</p>
<a id="more"></a>
<h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><h3 id="创建一个新的文章"><a href="#创建一个新的文章" class="headerlink" title="创建一个新的文章"></a>创建一个新的文章</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="运行服务"><a href="#运行服务" class="headerlink" title="运行服务"></a>运行服务</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="生成静态文件"><a href="#生成静态文件" class="headerlink" title="生成静态文件"></a>生成静态文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="部署到远程站点"><a href="#部署到远程站点" class="headerlink" title="部署到远程站点"></a>部署到远程站点</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;http://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;! 以下是Hexo的一些常用命令，如果需要详细了解,可以前往 &lt;a href=&quot;http://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;documentation&lt;/a&gt; 查询详细文档. 如果你在使用Hexo时出现问题，你可以在&lt;a href=&quot;http://hexo.io/docs/troubleshooting.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;troubleshooting&lt;/a&gt;搜索答案,或者可以前往Hexo的&lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;GitHub&lt;/a&gt;上提出问题.&lt;/p&gt;
    
    </summary>
    
    
      <category term="随笔" scheme="maple13.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
</feed>
